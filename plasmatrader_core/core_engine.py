"""
Core Engine for PlasmaTrader.

Handles the main trading loop, orchestration of modules, and core data structures.
"""

from __future__ import annotations

import datetime
from dataclasses import dataclass, field
from typing import List, Dict, Tuple

import pandas as pd

# --- Data Structures ---

@dataclass
class Position:
    """Represents an open position in the market."""
    symbol: str
    side: str  # 'LONG' or 'SHORT'
    size: float
    entry_price: float

@dataclass
class Trade:
    """Represents a single completed trade."""
    timestamp: datetime.datetime
    symbol: str
    side: str  # 'BUY' or 'SELL'
    price: float
    size: float
    pnl: float
    commission: float

@dataclass
class RiskMetrics:
    """Holds risk-related metrics."""
    current_drawdown: float = 0.0
    win_rate: float = 0.0
    high_water_mark: float = 10000.0  # Initial wallet balance

@dataclass
class MarketData:
    """
    Represents a snapshot of market data for a specific symbol.
    This includes real-time ticker info and order book depth.
    """
    timestamp: datetime.datetime
    symbol: str
    price: float
    bid: float
    ask: float
    spread: float  # In basis points
    top_5_bids: List[Tuple[float, float]] = field(default_factory=list)  # (price, quantity)
    top_5_asks: List[Tuple[float, float]] = field(default_factory=list)  # (price, quantity)
    trade_volume: float = 0.0 # Volume of last trade

@dataclass
class PredictionSignal:
    """
    Represents a trading signal generated by the Chronos predictor.
    """
    timestamp: datetime.datetime
    symbol: str
    fused_prediction_pct: float  # The final combined prediction as a percentage change
    confidence: float  # Confidence level of the prediction (0.0 to 1.0)
    decision: str  # 'LONG_ENTRY', 'SHORT_ENTRY', 'POSITION_HOLD', 'CLOSE_POSITION', 'WAITING'
    details: Dict[str, float] = field(default_factory=dict) # Per-timeframe predictions

@dataclass
class TradingState:
    """
    Represents the complete state of the trading system at any point in time.
    This object is what gets persisted to state.json.
    """
    timestamp: datetime.datetime
    wallet_balance: float
    positions: Dict[str, Position] = field(default_factory=dict)
    total_pnl: float = 0.0
    trades: List[Trade] = field(default_factory=list)
    risk_metrics: RiskMetrics = field(default_factory=RiskMetrics)
    historical_data: Dict[str, pd.DataFrame] = field(default_factory=dict) # Key: timeframe string e.g., '1m'

    def to_dict(self) -> Dict:
        """Converts the state to a dictionary for JSON serialization."""
        # Note: pd.DataFrame in historical_data is not directly JSON serializable
        # and will be handled during state persistence logic.
        return {
            "timestamp": self.timestamp.isoformat(),
            "wallet_balance": self.wallet_balance,
            "positions": {s: p.__dict__ for s, p in self.positions.items()},
            "total_pnl": self.total_pnl,
            "trades": [t.__dict__ for t in self.trades],
            "risk_metrics": self.risk_metrics.__dict__,
        }

    @classmethod
    def from_dict(cls, data: Dict) -> TradingState:
        """Creates a TradingState object from a dictionary."""
        positions = {s: Position(**p) for s, p in data.get("positions", {}).items()}
        trades = [Trade(**t) for t in data.get("trades", [])]
        risk_metrics = RiskMetrics(**data.get("risk_metrics", {}))

        return cls(
            timestamp=datetime.datetime.fromisoformat(data["timestamp"]),
            wallet_balance=data["wallet_balance"],
            positions=positions,
            total_pnl=data.get("total_pnl", 0.0),
            trades=trades,
            risk_metrics=risk_metrics,
        )

import copy
import json
import queue
import threading
import time
import logging

from plasmatrader_core import market_feed, chronos_predictor, risk_controller, paper_trader

# --- Configuration ---
INITIAL_BALANCE = 10000.0
SYMBOL = "BTCUSDT"
TIME_FRAMES = ["1m", "3m", "5m", "15m", "30m", "1h"]
HISTORICAL_LIMIT = 1000
PREDICTION_INTERVAL_S = 60
STATE_SAVE_INTERVAL_S = 300

logger = logging.getLogger(__name__)

# --- Initialization ---

def _validate_historical_data(df: pd.DataFrame, interval: str) -> bool:
    """Performs validation checks on historical data."""
    if df.isnull().values.any():
        logger.error("Validation failed: NaN values found.")
        return False
    if not all(df['volume'] >= 0):
        logger.error("Validation failed: Negative volume found.")
        return False

    # Check for significant price jumps
    price_change = df['close'].pct_change().abs().dropna()
    if any(price_change > 0.10):
        logger.warning("Validation warning: Large price jump (>10%) detected.")

    return True

def initialize_system() -> TradingState:
    """Initializes the system by fetching and validating data, and warming up the model."""
    logger.info("--- System Initialization Started ---")
    state = TradingState(
        timestamp=datetime.datetime.now(datetime.timezone.utc),
        wallet_balance=INITIAL_BALANCE,
        risk_metrics=RiskMetrics(high_water_mark=INITIAL_BALANCE)
    )

    for tf in TIME_FRAMES:
        logger.info(f"Fetching historical data for {tf}...")
        df = market_feed.fetch_historical_klines(SYMBOL, tf, HISTORICAL_LIMIT)
        if df.empty or not _validate_historical_data(df, tf):
            raise RuntimeError(f"Failed to fetch or validate historical data for {tf}")
        state.historical_data[tf] = df

    logger.info("Historical data fetched and validated.")

    logger.info("Warming up Chronos predictor...")
    _ = chronos_predictor.predict_multi_timeframe(state, SYMBOL)
    logger.info("Chronos predictor warmed up.")

    logger.info("--- System Initialization Complete ---")
    return state

# --- Main Loop ---

def main_trading_loop(state_lock: threading.Lock, cli_state: Dict):
    """The main orchestration loop."""

    try:
        state = initialize_system()
    except Exception as e:
        logger.critical(f"System initialization failed: {e}", exc_info=True)
        cli_state['status'] = f"FATAL: {e}"
        return

    data_queue = queue.Queue()
    risk_manager = risk_controller.RiskManager()
    paper_trader = paper_trader.PaperTradingEngine()

    def market_data_callback(market_data: MarketData):
        data_queue.put(market_data)

    ws_manager = market_feed.BinanceWebSocketManager(SYMBOL.lower(), market_data_callback)
    ws_manager.start()

    last_prediction_time = 0
    last_save_time = time.time()

    logger.info("--- Main Trading Loop Started ---")
    cli_state['status'] = "LIVE"

    while not cli_state.get('shutdown_requested', False):
        try:
            market_data = data_queue.get(timeout=1.0)

            with state_lock:
                state.timestamp = market_data.timestamp
                cli_state['state'] = copy.deepcopy(state)
                cli_state['market_data'] = market_data

            now = time.time()
            if now - last_prediction_time > PREDICTION_INTERVAL_S:
                last_prediction_time = now
                logger.info("Running prediction cycle...")

                with state_lock:
                    state_for_prediction = copy.deepcopy(state)

                prediction_signal = chronos_predictor.predict_multi_timeframe(state_for_prediction, SYMBOL)

                with state_lock:
                    cli_state['last_decision'] = prediction_signal.decision
                    cli_state['last_confidence'] = prediction_signal.confidence

                if prediction_signal.decision in ["LONG_ENTRY", "SHORT_ENTRY"]:
                    with state_lock:
                        state_for_execution = copy.deepcopy(state)

                    size = risk_manager.calculate_position_size(
                        state_for_execution, prediction_signal, market_data.price
                    )

                    if size > 0:
                        order = paper_trader.Order(
                            timestamp=datetime.datetime.now(datetime.timezone.utc),
                            symbol=SYMBOL,
                            side='BUY' if prediction_signal.decision == "LONG_ENTRY" else 'SELL',
                            size=size
                        )
                        new_state = paper_trader.execute_order(order, state_for_execution, market_data)

                        with state_lock:
                            state = new_state

            if now - last_save_time > STATE_SAVE_INTERVAL_S:
                last_save_time = now
                logger.info("Saving system state...")
                with state_lock:
                    with open("state.json", "w") as f:
                        json.dump(state.to_dict(), f, indent=2)
                logger.info("System state saved.")

        except queue.Empty:
            if not ws_manager._thread.is_alive():
                logger.error("WebSocket thread is not alive. Shutting down.")
                cli_state['status'] = "ERROR: WebSocket disconnected"
                break
            continue
        except Exception as e:
            logger.critical(f"Critical error in main loop: {e}", exc_info=True)
            cli_state['status'] = f"ERROR: {e}"
            time.sleep(5)

    logger.info("Shutdown requested. Cleaning up...")
    ws_manager.stop()
    logger.info("--- Main Trading Loop Stopped ---")
    cli_state['status'] = "SHUTDOWN"
